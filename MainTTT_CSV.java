import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

//This application is only valid for the Zwift game, from which included formulas and data are taken (i.e. 
//power calculation and air resistance reduction)
//TeamTimeTrail compete in groups of 4 - 6 riders who cycling in a row to reduce air resistance.
//The front rider will take 100% air second 78%, third 70% and the rest 67% (if they ride wheel to wheel without long distance between).
//During a race the riders will rotate continuously where the front rider shift to last position as so on. A ArrayList (durations) is
//created to hold the time for each rotational cycle. In this application "everything" are simplified and the rotational cycles
//are set to constant values: 60, 45, 30, 15 seconds (for 4 riders) where the strongest rider take 60s, second
//strongest 45 etc. (this value may be changed for different teams) The riders are ranked using theirs velocity they can hold for a 
//power of ftpFactor x FTP. ftpFactor is a factor raising the rider FPT at front (ex. for a factor of 1.2 a rider with 250W FTP shall
//hold 250 x 1.2 = 300W when sitting at the front). This speed is then constant during the race and each riders needed power for each
//position can be calculated.
//name = name of rider
//ftp = Functional Threshold Power
//weight = weight of rider in kg
//height = height of rider in cm
//velocity = the speed of a rider/team
//powerFront = power generated by front rider
//energyRace = assumed maximum energy (J) a rider can hold during the hole race
//ftpFactor = to be competitive the front rider must produce between 1.1 - 1.3 times his/her ftp (this factor is user input)
//approxRaceDuration = assumed duration (in minutes) of the hole race, which can be estimated by watching other races (it can't be 
//calculated by (duration x velocity) because the track profile which slows down the team.
//noOfCycles = one cycle is when the team has rotated its riders a full circle and noOfCycles is how many of those are required
//to complete the race
//The team is stored in ArrayList team which is populated from a CSV file (TTB2.csv)
//The formula to calculate the power vs velocity is taken from: https://julesandjames.blogspot.com/2021/04/speed-vs-power-in-zwift.html
//The air resistance reducing factors (0.78, 0.7, 0,67) may be changed with Zwift update of the algorithm

public class MainTTT_CSV {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
				
		System.out.println("Enter the FTP factor: (the front rider's FTP is raised with this factor)");
		System.out.println("Typicly the factor is between 1.1 - 1.3");
		String ftpFactorString = sc.nextLine();
		double ftpFactor = Double.valueOf(ftpFactorString);
		Cyclist.setFtpFactor(ftpFactor);//set factor before the constructor is called
		
		//the race duration can't be calculated by race length / speed because of climbs => estimate duration from other events
		System.out.println("Enter the approximate duration (in minutes) for the race:");
		String approxRaceDurationString = sc.nextLine();
		double approxRaceDuration = Double.valueOf(approxRaceDurationString);
		Cyclist.setDuration(approxRaceDuration);//set approxRaceDuration before the constructor is called
		double noOfCycles = 0;
		sc.close();
		
		//Create the TTT team by adding: Name, FTP, Weight and Height for each rider
		//Rider input from a csv file
		ArrayList<Cyclist> team = null;
		Scanner scCSV;
		try {
			scCSV = new Scanner(new File("C:\\Java\\Project-Jan2023\\IO\\src\\TTTB2.csv"));
			team = new ArrayList<>(); 
			
			while(scCSV.hasNext()) {
				String data = scCSV.next();
				String values[] = data.split(",");
				team.add(new Cyclist(values[0], Integer.parseInt(values[1]), Integer.parseInt(values[2]), Integer.parseInt(values[3])));
			}
			scCSV.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	//put durations of frontRider into a array, strongest rider first (60s) followed by second strongest (45s) etc.
	//no. of riders can be 4, 5 or 6
	//the durations can of course be changed to suit other team members	
	ArrayList<Integer> durations = new ArrayList<>();
	switch (team.size()) {
         case 4: durations.addAll(Arrays.asList(60, 45, 30, 15)); noOfCycles = (approxRaceDuration*60)/150; break;
         case 5: durations.addAll(Arrays.asList(56, 38, 29, 30, 24)); noOfCycles = (approxRaceDuration*60)/180; break;
         case 6: durations.addAll(Arrays.asList(60, 45, 30, 30, 15, 15)); noOfCycles = (approxRaceDuration*60)/195; break;
    }
    //create a HashMap and add each rider to a Key, the value will be added with energy later on
    Map<String, Double> totalEnergyMap = new HashMap<>();
    for(Cyclist i : team) {
		totalEnergyMap.put(i.getName(), 0.0);
	}
	//Print some data
    System.out.println();
    System.out.println("In below list the frontVelocity is calculated from frontPower = " +(ftpFactor*100) +"% of ftp");
    System.out.println("Energy avaiable for this race = 90% of resp. rider's ftp during " +approxRaceDuration +" min");
    System.out.println("-------------------------------------------------------------------------");
	for (int i = 0; i < team.size(); i++) {
		String name = team.get(i).getName();
		System.out.println(name);
		System.out.printf("frontPower = %.0f", team.get(i).getPowerFront());
		System.out.println(" (W)");
		double v = team.get(i).getVelocity();
		System.out.printf("frontVelocity = %.2f", v);
		System.out.println(" (km/h)");
		double energyRace = team.get(i).getEnergyRace();
		System.out.printf("Energy avaiable = %.0f", energyRace);
		System.out.println(" (J)");
		System.out.println();
	}
	Collections.sort(team, new Cyclist.CompByVelocity());//sort team by velocity, strongest rider first
															//see html at C:/Home/Java/TTT/file
	//the race speed is constant and set to the fourth strongest riders speed
	//team race time is set when forth rider pass finish line
	double raceSpeed = team.get(3).getVelocity();//4:th strongest rides velocity is choose as constant race Speed
	//System.out.println("Max velocity = " + maxVelocity +" km/h by " +nameFour);
	
	//Print riders velocity in order and use the 4:th fastest as race speed
    //The strongest rider ride at the highest speed, powering ftpFactor at front
    System.out.println("Sequence of riders with strongets first");
    System.out.println("------------------------------------------");
	for (int i=0; i<team.size(); i++) {
		System.out.printf("The velocity = %.2f", team.get(i).getVelocity());
		System.out.println(" by " +team.get(i).getName());
	}
	System.out.println();
	System.out.printf("Race Speed is set to 4:th fastes in above table = %.2f", raceSpeed);
	System.out.println();
	System.out.println();
	//calculate energy spent by a specific row (team order is constant) for durations specified in durations[]
	//for 6 riders there are 6 rows, 1:st with strongest rider first second strongest at second position etc.
	//in 2:nd row the first rides has moved to last position etc.
	//a for loop iterating durations[] array
 	for (int j = 0; j < durations.size(); j++) {
//		System.out.println();
		int duration = durations.get(j);
		
//		System.out.println("Duration " +duration +" (s) for below row"); //this can be used to print energy for every loop
		
		//the for loop iterating the team array and calculate each riders energy in their respective positions
		//1:st rider take 100% of air resistance, 2:nd has reduced air resistance (0.78) etc.
		//the duration[] array must correspond to the order of riders in the team array, strongest first etc.
		for (int i = 0; i < team.size(); i++) {
			double energy;
			switch(i) {
			case 0 -> energy = team.get(i).calcEnergy(duration, raceSpeed); 			//this case is for front rider
			case 1 -> energy = (team.get(i).calcEnergy(duration, raceSpeed)) * 0.78; 	//and this for second rider
			case 2 -> energy = (team.get(i).calcEnergy(duration, raceSpeed)) * 0.7; 	//this for third rider
			default -> energy = (team.get(i).calcEnergy(duration, raceSpeed)) * 0.67;	//this for rest of the riders
			}
			String riderName = team.get(i).getName();
			
//			System.out.println(riderName +" spend " + energy +" (J)");	//this can be used to print energy for every loop
			
			//the Map is summing up all energies for each rider
			//totalEnergyMap.get(riderName) is the energy stored from last loop and + energy
			//will add more energy from current loop
			totalEnergyMap.put(riderName, (totalEnergyMap.get(riderName) + energy));
		}
		//rotate the ArrayList, front rider go to last position
		Cyclist firstRider = team.remove(0);
		team.add(firstRider);
//			System.out.println();
	}
 	//print consumed energy during the race for each rider
 	System.out.println("Total energy consumption for each rider:");
 	for(Map.Entry<String, Double> entry : totalEnergyMap.entrySet()) {
 		Double temp = entry.getValue() * noOfCycles;
 		System.out.print(entry.getKey());
 		System.out.printf(" total energy consumption = %.0f", temp);
 		System.out.println(" (J)");
 	}
 	System.out.println("---------------------------------------------------------------");
 	//print available energy for each rider
	for (int i=0; i<team.size(); i++) {
	 	double energyRace = team.get(i).getEnergyRace();
	 	String name = team.get(i).getName();
	 	System.out.print(name);
		System.out.printf("'s Energy avaiable for this race = %.0f", energyRace);
		System.out.println(" (J)");
		//get the Map value for the same rider as "name" and calculate how much of the available energy is consumed
		//if the quote not is acceptable a new ftpFactor should be used
		double consumedEnergy = (totalEnergyMap.get(name)) * noOfCycles;
		double quote = (consumedEnergy / energyRace) * 100;
		System.out.printf("Consumed energy is %.0f", quote);
		System.out.println("% of Available energy");
		System.out.println("-----------------------------------------------------------");
	
	}
 	System.out.println();
	}
}
